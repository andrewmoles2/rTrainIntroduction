---
title: "R Fundamentals 9 - Making your own functions"
author:
   - name: Andrew Moles
     affiliation: Learning Developer, Digital Skills Lab
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document: 
    theme: readable
    highlight: pygments
    keep_md: yes
    code_download: true
    toc: true
    toc_float: true
---

# Objective of workshop

To start making your own functions to use for your data cleaning and analysis in R. 

# What this workshop will cover

In this workshop, the aim is to cover how to start making your own functions. We will be covering:

-   Introduce the basics of making functions
-   How to use functions you've made
-   Some general use cases to get you started

------------------------------------------------------------------------

Ideas:

- How to source functions you've made from a script
- How to comment your functions
- When to enforce user input to functions, and when to add defaults
- At end, tidy evaluation to access columns when your functions use tidyverse functions
- Example with `...`
- Example with `{{variable}}`

# Functions 101

Through your learning of R you will likely have used hundreds of functions. Building your own functions will allow you to start make your code more streamline as well as some automation. 

Functions are great at reducing your workload in the long run. Imagine you are an analyst and have to repeat some analysis steps over and over again. You could copy and paste your code several times, which is error prone. Or you could wrap up that code you are repeating into a function, saving you from copying and pasting lots of code! 

Functions have a basic structure: `name_of_function <- function(argument) {some code}` 

Within the `()` we have arguments

What are arguments and parameters?

Basic example, have a function that prints out a welcome message. 
```{r}
hello <- function(name) {
  # our code that uses name argument
  message <- paste0("Hello there ", name, ", welcome to R!")
  # return ensures function gives output
  return(message)
}

hello("Andrew")
```

The `return()` function is important, as it makes sure an output is given when the function is used. If we remove it nothing will happen. Run this code chunk to test it out. 
```{r}
hello2 <- function(name) {
  # our code that uses name argument
  message <- paste0("Hello there ", name, ", welcome to R!")
}

hello2("Andrew")
```

You can also add in default arguments to your functions. This is useful if you know what the argument will be most of the time. To add default arguments we would assign a value to our argument, in our example this would be `name = "Andrew"`. 
```{r}
hello <- function(name = "Andrew") {
  # our code that uses name argument
  message <- paste0("Hello there ", name, ", welcome to R!")
  # return ensures function gives output
  return(message)
}

hello()
```

## Build yourself a welcome message exercise

We are going to build a message that welcomes you according to what time of day it is. 

Debug the code to get it running. 
```{r}
welcome <- function(name) {
  name <- name
  hour <- format(Sys.time(), format = "%H")
  morning <- 0:11
  afternoon <- 12:16
  evening <- c(17:23)
  day_hrs <- rep(x = c("Morning", "Afternoon", "Evening"), 
    times = c(length(morning), length(afternoon), length(evening)))
  names(day_hrs) <- as.character(0:23)
  welcome <- paste0("Good ", day_hrs[hour], ", ", name, "!")
  return(welcome)
}

welcome("Andrew")
```

# Short hand functions

Functions can be written in short hand, which technically means you do not use the curly brackets `{}` when defining the function. This works well if you have very little code, but is not recommended if you have more than one line of code. 

Let's look at some examples. First, let's take our hello function from earlier and make it short hand. 
```{r}
hello3 <- function(name) paste0("Hello there ", name, ", welcome to R!")
hello3("Andrew")
```

This works well for this function as it is only one line of code. If the function got more complex we should put all the code into curly brackets `{}`. 

# Short hand functions exercise

Convert this function to a short hand function
```{r}
example_vect <- function(size) {
sample(
  x = c(1:20, rep(NA, 3)),
  size = size,
  replace = TRUE
)
}

example_vect(20)
```

```{r}
example_vect <- function(size) sample(x = c(1:20, rep(NA, 3)),size = size,replace = TRUE)

example_vect(20)
```

Function to change NA values to mean value of vector, using data generated from example_vect. 

```{r}
set.seed(1)
test <- example_vect(20)
test
round(mean(test, na.rm = T))

test[is.na(test)] = round(mean(test, na.rm = T))
test

# turn into a function
na_imput_mean <- function(x) {
  find_avg <- round(mean(x, na.rm = TRUE))
  x[is.na(x)] = find_avg
  return(x)
}

na_imput_mean(example_vect(20))

```


# Adding more arguments

Should really be no more than 3 if you can help if and the function should perform just one task. 

Example of making a range function, which is the difference between min and max values. 
```{r}
library(palmerpenguins)

range2 <- function(x, rem.na = TRUE) {
  #' @description This function calculates the range of min and max values
  #' @param x your data
  #' @param rem.na Should missing values to removed?
  #' 
  range <- max(x, na.rm = rem.na) - min(x, na.rm = rem.na)
  return(range)
}

range2(penguins$body_mass_g)
```

## Adding more arguments exercise

```{r}
odds <- function(x) subset(x, x %% 2 == 1)

evens <- function(x) subset(x, x %% 2 == 0)

odd_even <- function(x, odd = TRUE) {
  if (odd == TRUE) {
    subset(x, x %% 2 == 1)
  } else {
    subset(x, x %% 2 == 0)
  }
}

my_vec <- 1:20
odds(my_vec)
evens(my_vec)
odd_even(my_vec) # find odds
odd_even(my_vec, odd = FALSE) # find evens
```


# Applying functions you've made

What if as part of your job you need to workout what generation each person in your dataset is. The first set would be to build a function, then apply that function do your data. 

The first thing we do is build our function to tell you what *generation* you are in.
```{r}
# function to figure out your generation by birth year
generation <- function(birth_year) {
  if(birth_year >= 1997){
    gen <- "Gen Z"
  }
  else if(birth_year <= 1996 & birth_year >= 1981){
    gen <- "Millennial"
  }
  else if(birth_year <= 1980 & birth_year >= 1965){
    gen <- "Gen X"
  }
  else if(birth_year <= 1964 & birth_year >= 1955){
    gen <- "Boomer II"
  }
  else if(birth_year <= 1954 & birth_year >= 1946){
    gen <- "Boomer I"
  }
  else if(birth_year <= 1945 & birth_year >= 1928){
    gen <- "Post War"
  }
  else if(birth_year <= 1927 & birth_year >= 1922){
    gen <- "WW II"
  }
  else{
    gen <- "Not sure"
  }
  return(gen)
}

# test output
generation(1989)
```

Cool! How can we then apply that to some data? Because our function only works on one number at a time, we will need to *iteratively* use the function on each row of a data frame. 

In this example we make a data frame with some years and ids. We can then use one of the apply family of functions - these will be extensivily covered in *r-intermediate-2* - in order to use the function on each row of our data. 

We've used `vapply()` which takes 3 arguments. The data to apply function to, the function to use, and the data type of the output, which is character in this case. 
```{r}
# Make data frame
example_df <- data.frame(
  id = seq(1, 9),
  yob = round(runif(9, min = 1920, max = 2006))
)

# use function on yob column, apply it to each row
example_df$generation <- vapply(example_df[,"yob"], generation, FUN.VALUE = "character")

# print result
example_df
```

# Extra resources and ideas

GitHub is a great resource to store your code for projects or just little snippets of code. GitHub Gists are great for the little snippets of code that might not fit into their own project. Have a look at [this nice blog post](https://ikashnitsky.github.io/2023/gist-snippet/index.html) about how to pull your GitHub Gists into R to save you copy and pasting them from GitHub.

